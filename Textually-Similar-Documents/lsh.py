import numpy as npimport hashlib# The idea is that the signature matrix gets partitioned into n bands# The bands are then hashed# Whenever any two hashed subvectors are similar, they go to the same hash bucket# Now we assume that the two full vectors that the subvectors comes from are a candidate pair (i.e. similar)# There are assumptions: false negs, false pos may occure, but we assume that the amount of these are smallclass LHS:   def __init__(self, threshold=0.5):       self.threshold = threshold               #Different b valueS will return different amounts of FPs and FNs   def split(self, matrix, bands):       return np.split(matrix, bands)      def hash_entry(self, x):       x = repr(x).encode('utf-8')       return hashlib.md5(x).hexdigest()    #Hash each column within a band   def hash_bands(self, bands):       n = len(bands) #total num of bands       m =  len(bands[0]) # total num of rows in band       k = len(bands[0][0]) # total num of cols       hashed_bands = np.array(bands).flatten().tolist()      # hashed_bands = map(self.hash_entry, bands)       hashed_bands = list(hashed_bands)       hashed_bands = np.array(hashed_bands)       hashed_bands = np.reshape(hashed_bands, (n, m, k))              return hashed_bands      # sum the hashings up     def sum_hashed_bands(self, hashed_bands):       summed_hashed_bands = [[] for b in hashed_bands]       n = len(hashed_bands) #total num of bands       m =  len(hashed_bands[0]) # total num of rows in band       k = len(hashed_bands[0][0]) # total num of cols       for i in range(n):                            for j in range(m):               for g in range(1, k):                  # print("BUCKETS:", summed_hashed_bands[i])                   #current_hashed_band_vector = hashed_bands[i][g][j] + hashed_bands[i][g-1][j]                   summed_hashed_bands[i].append([hashed_bands[i][g][j] + hashed_bands[i][g-1][j]])                   #print("current:", current_hashed_band_vector)                 #  if(summed_hashed_bands[i][j][g] == summed_hashed_bands[i][j][g-1]):                  #     summed_hashed_bands[i].append([j+1, hashed_bands[i][g][j] + hashed_bands[i][g-1][j]])                                            print("hela", summed_hashed_bands)       return summed_hashed_bands      def find_candidate_pairs(self, summed_hashed_bands, bands):       count = 0       buckets = [[[] for bc in range(len(summed_hashed_bands[0]))] for bs in range(bands)] # as many buckets as hashed values       print(buckets)       current_hashed_band_vector = ''       #populate buckets       # if hashed value = same, it ends up in the same bucket. #       for i in range(len(buckets)): #          print(summed_hashed_bands[i])       n = len(summed_hashed_bands) #total num of bands       m =  len(summed_hashed_bands[0]) # total num of rows in band       k = len(summed_hashed_bands[0][0]) # total num of cols       print("k: ", k)       for i in range(n):                   print(i)            for j in range(m):               print(j)               for g in range(k):                   print(g)                   current_hashed_band_vector = summed_hashed_bands[i][j][g]                   print("hash", current_hashed_band_vector)                   print("wtf", buckets[i][j])                   if(buckets[i][j] == current_hashed_band_vector):                       buckets[i][j].append(current_hashed_band_vector)                   else:                       buckets[i][j].append(current_hashed_band_vector)                                                     print(buckets)          # print("i", i)      # It may be the case that vectors from different bands for one column are similar    # Before checking for candidate pairs, we need to remove those duplicates from each column    # Otherwise, we will not know    # def remove_duplicates_fromdef main():    lhs = LHS()    sample_signature_matrix = np.array([[1, 2], [3, 4], [5, 6], [1, 1], [3, 1], [11, 3]])    bands = lhs.split(sample_signature_matrix, 3)    hashed_bands = lhs.hash_bands(bands)    print(hashed_bands)    summed_hashed_bands = lhs.sum_hashed_bands(hashed_bands)    lhs.find_candidate_pairs(summed_hashed_bands, 3)  #  print("sha:", hashlib.sha256(5))main()'''TRASHBIN       #hashed_bands = [[] for b in range(len(bands))]       #hashed_bands.append([print(x) for x in bands])              #print(hashed_bands)       #return hashed_bands           for j in range(len(bands[0])):               #[repr(x).encode() for x in bands[i][j]]               #hashed_band_values.append([hashlib.md5(x).hexdigest() for x in bands[i][j]])               #print("hej", hashed_band_values)               pass               #for k in range(len(hashed_bands)):                #   hashed_bands[k] = hashlib.md5(k).hexdigest()                  # hashed_bands[i].append(hashed_band_values)           hashed_band_values= []           #for i in range(len(bands)):           #    print(i)           #    hashed_bands[i].append([print(x) for x in bands[i]])'''